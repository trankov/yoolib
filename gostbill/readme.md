# GostBill: ГОСТ Р 56042-2014


Инструмент создания кодовой строки для QR-платежей.

Для больших и маленьких проектов.

*PEP8 разрешает использовать комментарии на любом языке, если код будет поддерживаться только его носителями. В данном случае документация, комментарии и служебные сообщения реализованы на русском. ГОСТ РФ, по его природе, нужен только русскоговорящим.*

## Зачем всё это

ГОСТ основан на чужеродном для Python стандарте именования и оформлен в виде служебного документа. Чтобы написать формирование и валидацию данных, придётся этот документ полностью изучить. Данная библиотека позволяет не погружаться в бюрократический язык ГОСТа, а сразу начать работать.

Фактически, кодовая строка QR описывает выставленный счёт. В этой библиотеке мы формируем счета, а затем получаем их выражение в виде кодовой строки.

В общем случае, вы определяете шаблоны (один или несколько) для дальнейшего выставления счетов. Для этого библиотека содержит набор готовых дескрипторов с именами из ГОСТ. Вы присваиваете их атрибутам класса (шаблона), называя их, как вам удобно. Затем вы используете их в вашей предметной области, при этом сохраняя нужный вам язык предметной области.

Проще говоря, в классах вы сопоставляете ваши именования с теми, которые требует ГОСТ, и дальше просто забываете про него.

## Что ещё можно сделать

  - Определить и настроить разные шаблоны для разных целей приёма платежей
  - Автоматически заполнить нужные поля в шаблонах разными наборами данных при помощи классов-фабрик.
  - Автоматически получить документацию о полях счетов: как на основе ГОСТ, так и вашу собственную
  - Автоматически валидировать вводимые данные, в том числе собственными валидаторами
  - Сериализовать поля реквизитов и сами счета в нужный формат (или воспользоваться встроенными  сериализаторами)
  - Проверить наборы полей в шаблонах на соответствие требованиям ГОСТ
  - Обработать специфические исключения с точным указанием ошибки со ссылкой на ГОСТ


## Простой пример

```python
from gostbill import GostBill, fields


# Определяем шаблон счёта:

class Bill(GostBill):
    """Description of a bill"""

    amount = fields.Sum()
    recipient = fields.Name()

# Создаём конкретный счёт и заполняем реквизиты значениями:

new_bill = Bill()
new_bill.amount = 100
new_bill.recipient = 'Балаганов'

# Теперь у нас есть кодовая строка для QR

print(new_bill)
```

Готовый результат (кодовая строка) — это строковое представление экземпляра.

```sh
ST00012|Sum=100|Name=Балаганов
```

## Помимо кодовой строки

Шаблоны счетов, как показано в примере выше, заполняются при помощи дескрипторов атрибутов (таких, как `Sum()` или `Name()` из модуля `fields`). Кроме непосредственно значений, они также содержат дополнительную информацию о каждом поле выставленного счёта. Это, например, экономит время при работе с фронтендом, если ему нужны описания вводимых параметров.

```python
print(new_bill.serializer)
```

Вы можете легко написать свой сериализатор или воспользоваться готовым.

```json
{
    "name": "Bill",
    "encoding": "utf-8",
    "description": "Description of a bill",
    "fields": [
        {
            "name": "amount",
            "value": "100",
            "definition": "Sum",
            "short": "Сумма (коп.)",
            "long": "Сумма платежа в копейках",
            "required": false
        },
        {
            "name": "recipient",
            "value": "Балаганов",
            "definition": "Name",
            "short": "Получатель",
            "long": "Наименование получателя платежа",
            "required": true
        }
    ]
}
```

Также дескрипторы выполняют валидацию присваиваемого значения согласно описанным в ГОСТ ограничениям и генерируют специальные исключения, которые можно перехватывать для точечной обработки.

Реквизиты с постоянными значениями (например, данными о получателе) можно определить при помощи класса-фабрики. Он примет шаблон и вернёт частично заполненный счёт. Подробнее об этом рассказано ниже.

## Эта библиотека не рисует сам QR-код

Вы сами лучше знаете, каким способом вам его рисовать. В каких-то проектах это делается на фронтенде, в каких-то при помощи сторонних API. Кому-то нужен простой квадратик, кто-то хочет цветной, фигурный и с анимацией.

Если вы не знаете, какие инструменты выбрать, посмотрите на эти:
- [segno](https://github.com/heuer/segno): нативный инструмент со множеством настроек и возможностью расширения через плагины, который умеет всё
- [python-qrcode](https://github.com/lincolnloop/python-qrcode): старый проверенный пакет, который покрывает большинство простых задач

## Как тут всё устроено

В реальном мире мы выставляем счёт (bill), у которого есть реквизиты (requisites): банк, номер счёта, ИНН, сумма платежа и пр. Счёт формируется по тому или иному шаблону («по форме»): шаблон определяет, какие именно реквизиты в каком порядке надо заполнять.

В данной библиотеке шаблон счёта — это класс, а нужные в шаблоне реквизиты — атрибуты класса. Когда вы объявляете экземпляр этого класса и присваиваете значения атрибутам экземпляра, вы заполняете конкретный счёт, чтобы его выставить (показать qr-код).

Сначала опишем процесс кратко, а потом всё рассмотрим подробно.

1. Для декларации шаблона счёта вы наследуетесь от класса `GostBill`.
```python
from gostbill import GostBill


class Bill(GostBill):
    """Description of a bill"""
```

2. Для указания типа реквизита вы присваиваете атрибутам класса дескрипторы из модуля `fields`. Он мог бы называться `requisites`, но `fields` короче и интуитивнее. Полный список всех полей (fields) есть в конце этого документа. Их названия повторяют имена параметров в ГОСТ. А атрибуты вы называете так, как нужно вам.

```python
from gostbill import GostBill, fields


class Bill(GostBill):
    """Description of a bill"""

    amount = fields.Sum()
    recipient = fields.Name()
```

3. Объявляя экземпляр вашего класса, унаследованного от `GostBill`, вы получаете конкретный счёт. Но его ещё надо заполнить. Для этого вы присваиваете числовые либо строковые значения атрибутам экземпляра. Все значения автоматически проходят проверку и валидируются по ГОСТ. Насколько это возможно, используется приведение типов.

```python
new_bill = Bill()
new_bill.amount = 100
new_bill.recipient = 'Балаганов'
```

5. Кодовая строка для QR содержится в строковом представлении экземпляра (можно получить, передав его в `str()`, `f-string`, `print`, и т. п.)
```python
print(new_bill)

>>> ST00012|Sum=100|Name=Балаганов
```

6. Значение поля (оно же реквизит) доступно через точечную нотацию.

```python
new_bill.amount, new_bill.recipient

>>> ('100', 'Балаганов')
```

7. Полная информация о реквизите (он же поле) доступна через синтаксис «как у словаря».

```python
new_bill['amount'], new_bill['recipient']
```

В этом случае вернётся специальный тип `FieldInstance` (подробно — далее):

```python
(
     FieldInstance(
         name='amount',
         model=RequisiteModel(
             definition='Sum',
             short='Сумма (коп.)',
             long='Сумма платежа в копейках',
             required=False,
             validator=gostbill.validators.Sum
        ),
        value='100'
    ),
    FieldInstance(
        name='recipient',
        model=RequisiteModel(
            definition='Name',
            short='Получатель',
            long='Наименование получателя платежа',
            required=True,
            validator=gostbill.validators.Name
        ),
        value='Балаганов'
    )
)
```

## Когда можно начинать работать?

Если вы дочитали досюда, то этого уже достаточно для большинства простых задач. Не забудьте о списке возможных полей в конце документа.

Теперь рассмотрим все концепции подробно для тех, кто пишет более сложный продукт.

## Реквизиты

Когда мы работаем с конкретным счётом (экземпляром класса), нам нужны только значения реквизитов. Но на уровне шаблона каждый реквизит имеет название, описание, ограничения и пр. В работе они часто могут понадобиться.

В простейшем случае (один короткий шаблон) эти данные можно где-то как-то прописать вручную, но в целом удобно использовать уже готовые определения. Поэтому каждое поле реквизита содержит как своё непосредственное значение (например, "100" или "Балаганов"), так и информацию о том, что это за поле: как называется в ГОСТ, обязательно ли оно, что означает по-русски, и пр.

Наборы таких типовых данных у нас здесь называются **Моделями реквизитов**. Они декларированы в служебном модуле `requisite_models`, и автоматически содержатся во всех реквизитах, которые вы определите в шаблоне счёта.

### Модели реквизитов

Все реквизиты из модуля `fields` включают в себя экземпляр класса `RequisiteModel`, который содержит следующие атрибуты:

- `definition`: название поля реквизита согласно ГОСТ
- `short`: краткое описание реквизита (например, для подписей в GUI)
- `long`: полное описание по ГОСТ (например, для подсказок)
- `required`: (`bool`) обязательно ли это поле по ГОСТ
- `validator`: (`Callable`) функция, проверяющая присваиваемое значение по ГОСТ и возвращающая корректную строку со значением (либо поднимающая исключение)

Это может быть полезно не только как хранилище готовых данных. Зная эту информацию, вы можете сами переопределять модели и поля реквизитов, если вам это необходимо (например, для назначения собственных валидаторов или подписей).

Ниже в примере мы создадим свой аналог поля `Name`, для которого переопределим валидатор и длинное описание. Остальные значения Модели реквизита мы возьмём из стандартного `Name`. Затем на основе Модели реквизита мы создадим собственное поле для шаблона и применим его.

```python
from gostbill import (
    fields,
    GostBill,
    Requisite, # Родительский класс для дескрипторов
    requisite_models as rm,  # Пожертвуем для краткости
    validators
)


# Определяем собственный валидатор на основе стандартного:

def my_validator(name: str) -> str:
    # Произведём специфическую проверку:
    if 'Паниковский' in name:
        raise validators.RequisiteValidationError('Паниковский украл гуся!')
    # Теперь применим стандартную валидацию
    return validators.Name(name)


# Определяем собственную Модель реквизита на основе Name:

OurNameModel = rm.RequisiteModel(
    definition=rm.Name.definition,
    short=rm.Name.short,
    long='Наименование получателя платежа от О. Бендера',
    required=rm.Name.required,
    validator=my_validator,
)


# Создаём собственное поле реквизита с нашей моделью:

class OurName(Requisite):
    model = OurNameModel


# Используем наше поле реквизита вместо стандартного:

class OurBill(GostBill):
    amount = fields.Sum()
    recipient = OurName()
```

*Валидатор не может быть `None`. Если вы хотите отключить валидацию, возвращайте то же значение (например, через `lambda x: x`). Все значения, возвращаемые валидатором, должны быть приведены к типу `str`.*

Так как модель реквизита это обобщённая информация, в ней не хранится конкретное значение реквизита. Оно хранится в дескрипторе.

Если использование собственной Модели реквизита однократное, то  можно не декларировать новый дескриптор, а передать `RequisiteModel` уже имеющемуся дескриптору `Name` — в параметре `model`:

```python
class OurBill(GostBill):
    amount = fields.Sum()
    recipient = fields.Name(model=OurNameModel)
```

Модель можно описать и непосредственно при передаче параметра `model`:

```python
class OurBill(GostBill):
    amount = fields.Sum()
    recipient = fields.Name(
        model=rm.RequisiteModel(
            definition=rm.Name.definition,
            short=rm.Name.short,
            long='Наименование получателя платежа от О. Бендера',
            required=rm.Name.required,
            validator=my_validator,
        )
    )
```

Выбор стиля написания кода только за вами.

### Дескрипторы реквизитов

Здесь нет возможности подробно рассказывать, что такое дескриптор. Если вы с ними не знакомы (что вряд ли, если вы дочитали до этого места, но бывает разное), просто знайте, что можете с ними работать как с обычными атрибутами. Просто при присваивании и получении значения будет проходить его внутренняя проверка и обработка.

Каждому полю счёта, описанному в ГОСТ, соответствует **одноимённый** класс из модуля `fields`.

Важным преимуществом `fields`, помимо валидации и приведения типа, является возможность работать с тем языком предметной области, который принят в вашем проекте, а не с именами полей из ГОСТ. Так, в ГОСТ используется CamelCase, но вы можете декларировать атрибуты в snake_case. Поля счёта могут называться так же, как параметры запросов к платёжной системе, а данные о плательщиках — так же, как в вашем модуле авторизации пользователей.

Полный список полей находится в конце этого документа.

Дескриптор реквизита (он же — поле в вашем счёте) содержит Модель реквизита (в атрибуте `model`) и, собственно, само значение поля. При обычной работе с полем вы не можете получить доступ к Модели реквизита, так как поле всегда возвращает только прямое значение. Однако, если вы обратитесь к нему через синтаксис словаря (см. пример выше), вы получите специальный тип `FieldInstance`, который содержит следующие параметры:

- `name`: название поля в вашем шаблоне счёта так, как вы сами его определили
- `model`: Модель реквизита
- `value`: значение, присвоенное полю в настоящий момент

Имейте в виду, что эти значения доступны только для чтения. Вы не можете изменить состояние экземпляра счёта через присваивание внутри `FieldInstance`: это вызовет стандартное исключение `FrozenInstanceError`. Присвоить значение реквизиту можно только через присваивание атрибуту счёта, что отразится в атрибуте `value`.

### Сериализация реквизита

Если нам нужно больше, чем просто кодовая строка QR, мы, как правило, сталкиваемся с необходимостью сериализовать данные для дальнейшей их передачи куда-либо. Для этого каждый возвращаемый экземпляр `FieldInstance` содержит метод `serialize()`.

Метод `serialize(serializer: Callable)` принимает параметр `serializer`. В этот параметр вы можете передать свой класс, который принимает в качестве единственного аргумента данный экземпляр `FieldInstance`. Передаваемый класс должен содержать собственный метод, также под названием `serialize()`. Результат его вызова и будет возвращён:

```python
# Сам метод под капотом работает так:

def serialize(self, serializer: Callable = FieldSerializer):
    return serializer(self).serialize()
```

По умолчанию в него передаётся встроенный класс `FieldSerializer` из модуля `serializers`. Вы можете взять его как пример для собственных сериализаторов:

```python
# ./gostbill/serializers.py


class FieldSerializer:
    field: 'FieldInstance'

    def __init__(self, field: 'FieldInstance'):
        self.field = field

    def serialize(self) -> dict:
        return {
            'name': self.field.name,
            'value': self.field.value,
            'definition': self.field.model.definition,
            'short': self.field.model.short,
            'long': self.field.model.long,
            'required': self.field.model.required,
        }

    def __str__(self):
        return json.dumps(self.serialize())
```

Почему в качестве сериализатора передаётся класс, а не функция? Чтобы вы могли организовать более сложную внутреннюю логику, которую удобно тестировать, если есть такая необходимость.

В целом, сериализация зависит от конкретного проекта, поэтому здесь, в большей степени, предлагается механизм для внедрения собственных сериализаторов, а дефолтные просто реализуют наиболее общий подход.

### Итерация по реквизитам

Реквизиты в подклассах `GostBill` могут итерироваться в том порядке, котором они были декларированы. Так как они поддерживают вызовы `iter` и `next`, это, соответственно, позволяет использовать их и в цикле `for`.

При итерации будут возвращены объекты `FieldInstance`, а не прямые значения.

```python
for field in new_bill:
    print(field.model.short, field.value, sep=': ')

# Сумма (коп.): 100
# Получатель: Балаганов
```

Кроме того, возможно обращение к полю по числовому индексу:

```python
new_bill[0]

>>> FieldInstance(name='amount', model=RequisiteModel(definition='Sum', short='Сумма (коп.)', long='Сумма платежа в копейках', required=False, validator=gostbill.validators.Sum), value='100')
```

### Под капотом

Технически, вы можете получить список названий ваших полей через приватный атрибут `_fieldnames`...

```python
new_bill._fieldnames

>>> ['amount', 'recipient']
```

...а к моделям реквизитов обратиться через приватный атрибут `_attrs`, который возвращает их в виде `types.SimpleNamespace`:

```python
new_bill._attrs.amount.long

>>> 'Сумма платежа в копейках'
```

Это внутренний API, который вряд ли пригодится кому-то в реальных проектах. Однако, в редких случаях он может быть полезен (наверное). Оба эти атрибута так же только для чтения.

## Шаблоны и счета

Как уже не раз говорилось, для декларации класса шаблона нужно унаследоваться от класса `GostBill`.

### Параметры счёта

Помимо списка реквизитов, формат QR-кода включает служебную информацию. Как правило, установок по умолчанию достаточно, но могут быть ситуации, когда их надо изменить.

Для хранения установок шаблона существует специальный тип `ServiceData`. Доступны его следующие параметры:

  - `encoding`: цифровой номер кодировки текста (см. ниже)
  - `format_id`: формат данных
  - `format_version`: версия формата данных

Настройки по умолчанию хранятся в атрибуте шаблона `service_data`. При декларации шаблона они могут быть переопределены. Для всех трёх параметров определены собственные `Enum`-классы с набором возможных значений:

  - `ServiceData.Charset`
  - `ServiceData.FormatID`
  - `ServiceData.FormatVersion`

Однако, в текущей версии ГОСТ разные варианты может иметь только параметр `encoding`, остальные зарезервированы на будущее. Соответственно, кодировка это единственный параметр, который в настоящий момент может понадобиться переопределить.

```python
from gostbill import GostBill, ServiceData, fields


class Bill(GostBill):
    """Description of a bill"""

    # Переопределение дефолтной кодировки
    service_data = ServiceData(encoding=ServiceData.Charset.KOI8_R)

    amount = fields.Sum()
    recipient = fields.Name()
```

*ГОСТ прямо рекомендует использование 1-битных кодировок для большей ёмкости текста. Однако, на практике, российские банки, как правило, используют UTF-8. Поэтому, эта кодировка установлена по умолчанию.*

Сейчас ГОСТ допускает три кодировки, которым в `ServiceData.Charset` соответствуют одноимённые константы:

- `WIN1251`
- `UTF8`
- `KOI8_R`

В Python тип `str` использует UTF-8. Поэтому, для работы с однобайтными кодировками нужно использовать не строковое, а байтовое представление экземпляра класса.

```python
new_bill = Bill()
new_bill.amount = 100
new_bill.recipient = 'Балаганов'

bytes(new_bill)
```

Результат KOI-8-R в Unicode-выводе:

```python
b'ST00013|Sum=100|Name=\xf3\xc9\xc4\xcf\xd2\xcf\xd7'
```

Помимо `service_data`, шаблон счёта использует параметр `delimiter`, всегда равный символу прямой черты: `|`. Это единственно допустимый по ГОСТ разделитель, и для формирования QR его не требуется переопределять. Но если назначить ему любое другое строковое значение, это будет работать:

```python
class Bill(GostBill):
    delimiter = ';'
    ...

# Вот только этот QR-код не будет распознан
>>> 'ST00012;Sum=100;Name=Балаганов'

```

При итерации по атрибутам счёта (см. выше) задействуются только дескрипторы реквизитов. Ни служебные, ни определённые пользователем атрибуты иного типа не итерируются.

### Функция `len()`

При использовании `len(new_bill)` будет возвращено **количество полей в счёте** (в нашем примере `2`), а **не длина кодовой строки QR** (в нашем примере `28`). Для строки нужно вычислять непосредственно её длину: `len(str(new_bill))` или `len(bytes(new_bill))`.

### Сериализация счёта

Сериализация счёта устроена иначе, чем сериализация поля и не требует специальных методов для пользовательских форматов.

Так как поля счёта итерируются и могут принимать кастомный сериализатор, у вас развязаны руки:

```python
from gostbill import GostBill, FieldInstance


# Сериализатор для реквизитов:

class HTMLSerializer:
    def __init__(self, field: FieldInstance):
        self.field = field

    def serialize(self) -> str:
        return f"""
        <h2>{self.field.name}</h2>
        <ul>
            <li>value: {self.field.value}</li>
            <li>description: {self.field.model.long}</li>
        </ul>
"""


# А сам счёт мы сериализуем с ходу:

def bill_html(bill: GostBill):
    fields_html = ''.join(
        field.serialize(HTMLSerializer)
        for field in bill
    )
    return f"""
<html>
    <body>
        <h1>{bill.__class__.__name__}</h1>
        <p>{bill.__doc__}</p>
        <code>{bill}</code>
        {fields_html}
    </body>
<html>
"""


print(bill_html(new_bill))
```

Результат:

```html
<html>
    <body>
        <h1>Bill</h1>
        <p>Description of a bill</p>
        <code>ST00012|Sum=100|Name=Балаганов</code>

        <h2>amount</h2>
        <ul>
            <li>value: 100</li>
            <li>description: Сумма платежа в копейках</li>
        </ul>

        <h2>recipient</h2>
        <ul>
            <li>value: Балаганов</li>
            <li>description: Наименование получателя платежа</li>
        </ul>

    </body>
<html>
```

Для удобства, каждый счёт содержит *свойство* `serializer`, возвращающее `BillSerializer.serialize(self) -> dict`. См. пример его работы в начале. Если вы хотите сохранить API библиотеки, переопределите это свойство самостоятельно:

```python
class Bill(GostBill):
    """Description of a bill"""

    amount = fields.Sum()
    recipient = fields.Name()

    @property
    def serializer(self) -> str:
        return bill_html(self)
```

В целом, сериализация зависит от конкретного проекта, поэтому здесь, в большей степени, предлагается механизм для внедрения собственных сериализаторов, а не готовые решения. Дефолтные сериализаторы включены для быстрого старта и рассчитаны на простые типовые задачи. Также они могут быть использованы как примеры для собственных решений.

## Типы исключений

При проверке корректности работы дескриптора реквизитов используется исключение `core.RequisiteError`. Оно будет вызвано, если пользовательские поля реквизитов определены неверно.

Более полезным является исключение `validators.RequisiteValidationError`, вызываемое при валидации присваиваемых значений. Оно возвращает подробную информацию об ошибке на русском языке со ссылкой на соответствующий параграф в ГОСТ.

Например, попытка неверно обозначить БИК:

```python
from gostbill import GostBill, fields


class Bill(GostBill):
    amount = fields.Sum()
    recipient = fields.Name()
    bic = fields.BIC()


new_bill = Bill()
new_bill.amount = 100
new_bill.bic = '0921247'
```

Вызовет исключение:

```python
RequisiteValidationError: "ГОСТ § 5.2.3, Таблица 2: БИК — Строка цифр строго 9 знаков. Вы передали BIC '0921247', знаков: 7"
```
## Стандартные формы счетов

Согласно ГОСТ, в кодируемой строке допустимы три блока реквизитов:

Блок 1. Обязательные, определённые в блоке «Payee» УФЭБС:
- `Name`
- `PersonalAcc`
- `BankName`
- `BIC`
- `CorrespAcc`

Блок 2. Дополнительные, согласно Альбому УФЭБС:
  - `Sum`
  - `Puprose`
  - `PayeeINN`
  - `PayerINN`
  - `DrawerStatus`
  - `KPP`
  - `CBC`
  - `OKTMO`
  - `PaytReason`
  - `TaxPeriod`
  - `DocNo`
  - `DocDate`
  - `TaxPaytKind`

Блок 3. Прочие дополнительные реквизиты.

Может возникнуть необходимость проверки этих условий. Для этого определены три свойства экземпляра счёта:

  - `required_satisfied`:  вернёт`True`, если все обязательные реквизиты из п. 1 определены, иначе `False`
  - `additional_satisfied`: вернёт `True`, если все необязательные реквизиты из п. 2 определены, иначе `False`
  - `definitions_correct`: вернёт `True`, если все указанные реквизиты содержат корректные значения `model.definition` (иными словами, названия всех указанных реквизитов присутствуют в ГОСТ).

Таким образом, минимальная проверка счёта на то, что его шаблон соответствует требованиям ГОСТ, выглядит так:

```python
assert new_bill.required_satisfied and new_bill.definitions_correct

>>> False
```

В нашем рабочем примере все поля названы корректно, но не все обязательные поля указаны, поэтому вернётся `False`.

Важно знать, что не все банки требуют соблюдения этих требований при выставлении счёта, поэтому такая проверка нужна не всегда.

Если вам нужны специфичные проверки, используйте Enum-класс `BankingDetails` из модуля `core_models`. Он содержит константы `REQUIRED` (для блока 1), `ADDITIONAL` (для блока 2) и `OPTIONAL` (для блока 3). Их значениями являются множества (`set`) строковых наименований полей, входящих в каждый блок. Объединённое множество из всех трёх доступно в методе класса `full_set()`.

```python
from gostbill.core_models import BankingDetails


print(OurNameModel.definition in BankingDetails.full_set())
>>> True

print(OurNameModel.definition in BankingDetails.ADDITIONAL)
>>> False
```

## Счета с заранее заполненными реквизитами

Как правило, в жизни мы заполняем счета, на которых, как минимум, реквизиты получателя уже напечатаны. В проекте, например, это могут быть одни и те же шаблоны, выставляемые разными банками для разных плательщиков.

Например, квитанция об оплате домофона содержит одни и те же поля, но разные районы обслуживают разные операторы, каждый с собственными реквизитами. Эти же операторы выставляют счета за видеонаблюдение, уже с другим набором полей.

В этом случае, помимо определения пустого шаблона, возникает необходимость иметь его несколько частично заполненных вариантов, при этом не раздувая код. Это можно сделать при помощи класса-фабрики, в котором заранее задаются некоторые значения. Затем фабрика возвращает экземпляр счёта на основе переданного шаблона. Указанные в фабрике поля будут заполнены в этом счёте согласно образцу.

Одна и та же фабрика может принимать разные шаблоны, и один и тот же шаблон можно передавать в разные фабрики.

Так же, как для создания шаблона мы наследуемся от `GostBill`, для создания фабрики мы наследуемся от `BillFactory`.

```python
from gostbill.factories import BillFactory


# Определяем свою фабрику, в которой заранее заполнены
# некоторые реквизиты получателя.

class HerculesFactory(BillFactory):
    recipient = 'Полыхаев'
    bic = '284016348'
    wrong = 'Такого поля в шаблоне нет'


# Заполняем эти реквизиты для счёта по шаблону Bill,
# а затем вручную указываем переменные значения

another_bill = HerculesFactory.create_bill(Bill)
another_bill.amount = 1000
```

Поля, которые объявлены в фабрике, но отсутствуют в переданном шаблоне, будут проигнорированы. Это позволяет гибко задавать наборы значений реквизитов, которые будут применяться к разным шаблонам с разным набором полей. Мы можем безболезненно передавать разные по структуре шаблоны в одну и ту же фабрику, и она будет заполнять только те поля, которые указаны в переданном шаблоне.

```python
>>> another_bill
>>> Bill(Sum=1000, Name=Полыхаев, BIC=284016348)

>>> str(another_bill)
>>> 'ST00012|Sum=1000|Name=Полыхаев|BIC=284016348'
```

Фабрика принимает класс шаблона и инициализирует его, заполняя значениями установленные поля.

Таким образом, возвращаемый экземпляр счёта ничем не отличается от заполненного "вручную". Автоматически заполненные фабрикой поля реквизитов впоследствии могут редактироваться без каких-то специальных ограничений.

## Итог

Импортируем, декларируем, инстанцируем (через фабрику или вручную), указываем детали платежа, рисуем QR-код и отправляем на клиент (или на печать). Красота.


## Поля реквизитов из модуля `fields`

| ГОСТ              | SHORT                              | LONG                                                              | REQUIRED | VALIDATOR                                 |
| ----------------- | ---------------------------------- | ----------------------------------------------------------------- | -------- | ----------------------------------------- |
| `Name`            | Получатель                         | Наименование получателя платежа                                   | `True`   | `Name(name) -> str`                       |
| `PersonalAcc`     | Расчётный счёт                     | Расчётный счёт получателя платежа                                 | `True`   | `PersonalAcc(personalacc) -> str`         |
| `BankName`        | Банк                               | Наименование банка получателя платежа                             | `True`   | `BankName(bankname) -> str`               |
| `BIC`             | БИК                                | Банковский идентификационный код РФ                               | `True`   | `BIC(bic) -> str`                         |
| `CorrespAcc`      | Коррсчёт                           | Корреспондентский счёт банка                                      | `True`   | `CorrespAcc(correspacc) -> str`           |
| `Sum`             | Сумма (коп.)                       | Сумма платежа в копейках                                          | `False`  | `Sum(sum_) -> str`                        |
| `Puprose`         | Назначение                         | Наименование платежа (назначение)                                 | `False`  | `Puprose(puprose) -> str`                 |
| `PayeeINN`        | ИНН получателя                     | Идентификационный номер налогоплательщика получателя платежа      | `False`  | `PayeeINN(payeeinn) -> str`               |
| `PayerINN`        | ИНН плательщика                    | Идентификационный номер налогоплательщика плательщика платежа     | `False`  | `PayerINN(payerinn) -> str`               |
| `DrawerStatus`    | Статус составителя                 | Статус составителя платёжного документа                           | `False`  | `DrawerStatus(drawerstatus) -> str`       |
| `KPP`             | КПП                                | Код причины постановки на учет                                    | `False`  | `KPP(kpp) -> str`                         |
| `CBC`             | КБК                                | Код бюджетной классификации                                       | `False`  | `CBC(cbc) -> str`                         |
| `OKTMO`           | ОКТМО                              | Общероссийский классификатор территорий муниципальных образований | `False`  | `OKTMO(oktmo) -> str`                     |
| `PaytReason`      | Основание налогового платежа       | Основание налогового платежа                                      | `False`  | `PaytReason(paytreason) -> str`           |
| `TaxPeriod`       | Налоговый период                   | Налоговый период                                                  | `False`  | `TaxPeriod(taxperiod) -> str`             |
| `DocNo`           | Номер документа                    | Номер документа                                                   | `False`  | `DocNo(docno) -> str`                     |
| `DocDate`         | Дата документа                     | Дата документа                                                    | `False`  | `DocDate(docdate) -> str`                 |
| `TaxPaytKind`     | Тип платежа                        | Тип платежа                                                       | `False`  | `TaxPaytKind(taxpaytkind) -> str`         |
| `LastName`        | Фамилия                            | Фамилия плательщика                                               | `False`  | `LastName(lastname) -> str`               |
| `FirstName`       | Имя                                | Имя плательщика                                                   | `False`  | `FirstName(firstname) -> str`             |
| `MiddleName`      | Отчество                           | Отчество плательщика                                              | `False`  | `MiddleName(middlename) -> str`           |
| `PayerAddress`    | Адрес плательщика                  | Адрес плательщика                                                 | `False`  | `PayerAddress(payeraddress) -> str`       |
| `PersonalAccount` | Лицевой счёт                       | Лицевой счёт бюджетного получателя                                | `False`  | `PersonalAccount(personalaccount) -> str` |
| `DocIdx`          | Индекс                             | Индекс платёжного документа                                       | `False`  | `DocIdx(docidx) -> str`                   |
| `PensAcc`         | СНИЛС                              | Страховой номер индивидуального лицевого счета                    | `False`  | `PensAcc(pensacc) -> str`                 |
| `Contract`        | Номер договора                     | Номер договора                                                    | `False`  | `Contract(contract) -> str`               |
| `PersAcc`         | Номер лицевого счёта               | Номер лицевого счета плательщика в организации                    | `False`  | `PersAcc(persacc) -> str`                 |
| `Flat`            | Квартира                           | Номер квартиры                                                    | `False`  | `Flat(flat) -> str`                       |
| `Phone`           | Телефон                            | Номер телефона                                                    | `False`  | `Phone(phone) -> str`                     |
| `PayerIdType`     | Документ                           | Вид документа, удостоверяющего личность плательщика               | `False`  | `PayerIdType(payeridtype) -> str`         |
| `PayerIdNum`      | Номер документа                    | Номер документа, удостоверяющего личность плательщика             | `False`  | `PayerIdNum(payeridnum) -> str`           |
| `ChildFio`        | ФИО ребёнка/учащегося              | ФИО ребёнка/учащегося                                             | `False`  | `ChildFio(childfio) -> str`               |
| `BirthDate`       | Дата рождения                      | Дата рождения                                                     | `False`  | `BirthDate(birthdate) -> str`             |
| `PaymTerm`        | Срок платежа/счёта                 | Срок платежа или выставления счёта                                | `False`  | `PaymTerm(paymterm) -> str`               |
| `PaymPeriod`      | Период оплаты                      | Период оплаты                                                     | `False`  | `PaymPeriod(paymperiod) -> str`           |
| `Category`        | Вид платежа                        | Вид платежа                                                       | `False`  | `Category(category) -> str`               |
| `ServiceName`     | Код услуги/прибор учёта            | Код услуги или название прибора учёта                             | `False`  | `ServiceName(servicename) -> str`         |
| `CounterId`       | Номер прибора                      | Номер прибора учёта                                               | `False`  | `CounterId(counterid) -> str`             |
| `CounterVal`      | Показания                          | Показание прибора учёта                                           | `False`  | `CounterVal(counterval) -> str`           |
| `QuittId`         | Номер документа об оплате          | Номер извещения, начисления, счёта или постановления (для ГИБДД)  | `False`  | `QuittId(quittid) -> str`                 |
| `QuittDate`       | Дата документа об оплате           | Дата извещения, начисления, счёта или постановления (для ГИБДД)   | `False`  | `QuittDate(quittdate) -> str`             |
| `InstNum`         | Номер учреждения                   | Номер учреждения (образовательного, медицинского)                 | `False`  | `InstNum(instnum) -> str`                 |
| `ClassNum`        | Номер группы/класса                | Номер группы детского сада или класса школы                       | `False`  | `ClassNum(classnum) -> str`               |
| `SpecFio`         | ФИО специалиста                    | ФИО преподавателя, специалиста, оказывающего услугу               | `False`  | `SpecFio(specfio) -> str`                 |
| `AddAmount`       | Сумма начисления                   | Сумма страховки, дополнительной услуги или пени                   | `False`  | `AddAmount(addamount) -> str`             |
| `RuleId`          | Номер постановления                | Номер постановления (для ГИБДД)                                   | `False`  | `RuleId(ruleid) -> str`                   |
| `ExecId`          | Номер исполнительного производства | Номер исполнительного производства                                | `False`  | `ExecId(execid) -> str`                   |
| `RegType`         | Код платежа                        | Код вида платежа                                                  | `False`  | `RegType(regtype) -> str`                 |
| `UIN`             | УИН                                | Уникальный идентификатор начисления                               | `False`  | `UIN(uin) -> str`                         |
| `TechCode`        | Технический код                    | Технический код, рекомендуемый для заполнения поставщиком услуг   | `False`  | `TechCode(techcode) -> str`               |

# GostBill: ГОСТ Р 56042-2014

Инструмент создания валидной строки платёжных реквизитов при помощи шаблонов для формирования QR-кода.

*PEP8 разрешает не использовать англоязычные комментарии в  коде, который будет поддерживаться только носителями одного языка. Так как здесь реализован стандарт РФ, все комментарии и служебные сообщения написаны на русском языке. Это сделано сознательно. Российский ГОСТ вряд ли понадобится кому-то, кроме носителей русского языка.*

## Зачем всё

ГОСТ основан на чужеродном для Python стандарте и оформлен в виде служебного документа. Чтобы написать формирование данных и их валидацию, придётся его полностью изучить. Этот пакет позволит не погружаться в бюрократический язык ГОСТа, а сразу начать работать.

В общем случае здесь вы определяете шаблон для выставления счёта при помощи готовых дескрипторов и используете его в вашей предметной области (при этом сохраняя нужный вам язык предметной области в контрактах API и вообще везде за пределами декларации шаблона счёта).

## Пример

```python
from gostbill import GostBill, fields


class Bill(GostBill):
	"""Description of bill"""

	amount = fields.Sum()
	recipient = fields.Name()


new_bill = Bill()
new_bill.amount = 100
new_bill.recipient = 'Сидоров'

print(new_bill)
```

Готовый результат — это строковое представление экземпляра класса.

```sh
ST00012|Sum=100|Name=Сидоров
```

## Возможности

Шаблоны счетов определяются при помощи полей-дескрипторов, которые также содержат дополнительную информацию о каждом поле выставленного счёта. Это экономит время при работе с фронтендом.

```python
print(new_bill.serializer)
```

Вы можете легко написать свой сериализатор или воспользоваться готовым.

```json
{
    "name": "Bill",
    "encoding": "utf-8",
    "description": "Description of bill",
    "fields": [
        {
            "name": "amount",
            "value": "100",
            "definition": "Sum",
            "short": "Сумма (коп.)",
            "long": "Сумма платежа в копейках",
            "required": false
        },
        {
            "name": "recipient",
            "value": "Сидоров",
            "definition": "Name",
            "short": "Получатель",
            "long": "Наименование получателя платежа",
            "required": true
        }
    ]
}
```

Также дескрипторы выполняют валидацию присваиваемого значения согласно описанным в ГОСТ ограничениям и генерируют специальные исключения, которые можно перехватывать для точечной обработки.

## Эта библиотека не рисует сам QR-код

Вы сами лучше знаете, каким способом его рисовать. В каких-то проектах это делается на фронтенде, в каких-то при помощи сторонних API. Кому-то нужен простой квадратик, кто-то хочет цветной, фигурный и с анимацией.

Если вы не знаете, какие инструменты выбрать, посмотрите на эти:
- [segno](https://github.com/heuer/segno): нативный инструмент со множеством настроек и возможностью расширения через плагины
- [python-qrcode](https://github.com/lincolnloop/python-qrcode): старый проверенный пакет, который умеет всё необходимое

## Как тут всё устроено

В реальном мире мы выставляем счёт (bill), у которого есть реквизиты (requisites): банк, номер счёта, ИНН, сумма платежа и пр. Счёт формируется по тому или иному шаблону («по форме»): шаблон регламентирует, какие именно реквизиты в каком порядке надо заполнять.

В данном пакете шаблон счёта — это класс, а требуемые в шаблоне реквизиты — атрибуты класса. Когда вы объявляете экземпляр этого класса и присваиваете значения его атрибутам, вы заполняете конкретный счёт, чтобы его выставить (показать qr-код).

Сначала опишем процесс кратко, а потом остановимся на ряде пунктов подробно.

1. Для декларации шаблона счёта вы наследуетесь от класса `GostBill`.
```python
from gostbill import GostBill


class Bill(GostBill):
    """Description of bill"""
```

2. Для указания типа реквизита вы присваиваете атрибутам в качестве значения дескрипторы из модуля `fields`. Их полный список есть в конце этого документа.
```python
from gostbill import GostBill, fields


class Bill(GostBill):
	"""Description of bill"""

	amount = fields.Sum()
	recipient = fields.Name()
```

3. Объявляя экземпляр вашего подкласса `GostBill`, вы получаете конкретный счёт, полям которого присваиваете числовые либо строковые значения. Значения автоматически проходят проверку. Насколько это возможно, используется приведение типов. Кроме того, значения валидируются по ГОСТ.
```python
new_bill = Bill()
new_bill.amount = 100
new_bill.recipient = 'Сидоров'
```

5. Значение для QR-кода содержится в строковом представлении экземпляра класса (можно получить, передав его в `str()` и т.п.)
```python
print(new_bill)

>>> ST00012|Sum=100|Name=Сидоров
```

6. Доступ к значению поля осуществляется через точечную нотацию.
```python
new_bill.amount, new_bill.recipient

>>> ('100', 'Сидоров')
```

7. Доступ к информации о поле осуществляется через синтаксис «как у словаря».
```python
new_bill['amount'], new_bill['recipient']
```

В этом случае вернётся специальный тип `FieldInstance` (подробно — далее):

```python
(
	 FieldInstance(
		 name='amount',
		 model=RequisiteModel(
			 definition='Sum',
			 short='Сумма (коп.)',
			 long='Сумма платежа в копейках',
			 required=False,
			 validator=gostbill.validators.Sum
		),
		value='100'
	),
	FieldInstance(
		name='recipient',
		model=RequisiteModel(
			definition='Name',
			short='Получатель',
			long='Наименование получателя платежа',
			required=True,
			validator=gostbill.validators.Name
		),
		value='Сидоров'
	)
)
```

Теперь подробно.

## Реквизиты

Когда мы работаем с конкретным счётом (экземпляром класса), нам нужны только значения реквизитов. Но на уровне шаблона каждый реквизит имеет название, описание, ограничения и пр.

В простейшем случае (один короткий шаблон) эти данные можно прописать вручную, но в целом удобно использовать уже готовые определения. Поэтому каждое поле реквизита содержит как своё непосредственное значение (например, "100" или "Сидоров"), так и информацию о том, что это за поле: как называется в ГОСТ, обязательно ли оно, что означает по-русски, и пр.

Наборы таких данных здесь называются моделями реквизитов. Они декларированы в модуле `requisite_models`, и автоматически содержатся во всех реквизитах, которые вы определите в шаблоне счёта.

### Модели реквизитов

Все реквизиты из модуля `fields` включают в себя экземпляр класса `RequisiteModel`, который содержит следующие атрибуты:

- `definition`: название поля реквизита согласно ГОСТ
- `short`: краткое описание реквизита (например, для подписей в GUI)
- `long`: полное описание по ГОСТ (например, для подсказок)
- `required`: (`bool`) обязательно ли это поле по ГОСТ
- `validator`: (`Callable`) функция, проверяющая присваиваемое значение по ГОСТ

Зная эту информацию, вы можете сами переопределять модели и поля реквизитов, если вам это необходимо (например, для назначения собственных валидаторов или подписей).

```python
from gosbill import fields, GostBill, Requisite, requisite_models, validators


# Определяем собственный валидатор:

def my_validator(name: str) -> str:
	# Произведём специфическую проверку:
	if 'Паниковский' in name:
		raise validators.RequisiteValidationError('Паниковский украл гуся')
	# Теперь применим стандартную валидацию
	return validators.Name(name)


# Определяем собственную модель реквизита Name:

OurNameModel = requisite_models.RequisiteModel(
	definition=requisite_models.Name.definition,
	short=requisite_models.Name.short,
	long='Наименование получателя платежа (по требованиям командора)',
	required=requisite_models.Name.required,
	validator=my_validator,
)


# Создаём собственное поле реквизита с нашей моделью:

class OurName(Requisite):
	model = OurNameModel


# Используем наше поле реквизита вместо стандартного:

class OurBill(GostBill):
	amount = fields.Sum()
	recipient = OurName()
```

*Валидатор не может быть `None`. Если вы хотите отключить валидацию, возвращайте то же значение (например, через `lambda x: x`). Все значения, возвращаемые валидатором, должны быть приведены к типу `str`.*

Так как модель реквизита это обобщённая информация, в ней не хранится конкретное значение реквизита. Оно хранится в дескрипторе. Дескрипторы содержатся в модуле `fields`.

Существует возможность назначить `RequisiteModel` без объявления специального дескриптора поля. Для этого в декларации шаблона нужно передать его уже имеющемуся дескриптору в параметре `model`:

```python
class OurBill(GostBill):
	amount = fields.Sum()
	recipient = fields.Name(model=OurNameModel)
```

Или даже объявить модель непосредственно при передаче параметра:

```python
class OurBill(GostBill):
	amount = fields.Sum()
	recipient = fields.Name(
		model=requisite_models.RequisiteModel(
			definition=requisite_models.Name.definition,
			short=requisite_models.Name.short,
			long='Наименование получателя платежа (по требованиям командора)',
			required=requisite_models.Name.required,
			validator=my_validator,
		)
	)
```

Выбор стиля кодирования за вами.

### Дескрипторы реквизитов

Здесь нет возможности подробно рассказывать о том, что такое дескриптор, и если вы с ними не знакомы, просто знайте, что можете с ними работать как с обычными атрибутами. Однако, при присваивании и получении значения будет проходить его  внутренняя проверка и обработка. Каждому полю счёта, описанному в ГОСТ, соответствует **одноимённый** класс из модуля `fields`.

Важным преимуществом `fields`, помимо валидации и приведения типа, является возможность работать с тем языком предметной области, который принят в вашем проекте, а не с именами полей из ГОСТ. Так, в ГОСТ используется CamelCase, но вы можете декларировать атрибуты в snake_case. Поля счёта могут называться так же, как параметры запросов к платёжной системе, а данные о плательщиках — так же, как в вашем модуле авторизации пользователей.

Полный список полей находится в конце этого документа.

Дескриптор реквизита (он же — поле в вашем счёте) содержит модель реквизита (в атрибуте `model`) и собственно значение поля. При обычной работе с полем реквизита вы не можете получить доступ к модели реквизита, так как поле всегда возвращает только прямое значение. Однако, если вы обратитесь к нему через синтаксис словаря (см. пример выше), вы получите специальный тип `FieldInstance`, который содержит следующие параметры:

- `name`: название поля в вашем шаблоне счёта так, как вы сами его определили
- `model`: модель реквизита с информацией о нём
- `value`: значение, присвоенное полю реквизита в настоящий момент

Имейте в виду, что эти значения доступны только для чтения. Вы не можете изменить состояние экземпляра счёта через присваивание в `FieldInstance`, это вызовет стандартное исключение `FrozenInstanceError`. Присвоить значение реквизиту можно только через присваивание атрибуту счёта, что отразится в атрибуте `value`.

### Сериализация реквизита

Кроме того, возвращаемый экземпляр `FieldInstance` содержит метод `serialize()`, который принимает параметр `serializer: Callable`. По умолчанию в него передаётся встроенный `FieldSerializer` из модуля `serializers`. Вы можете, при необходимости, передать туда собственный `Callable`-объект, который принимает в качестве единственного аргумента данный экземпляр `FieldInstance` и содержит собственный встроенный метод `.serialize()`, возвращающий `dict` или любой другой тип, а также имеет строковое представление `__str__`.

В целом, сериализация зависит от конкретного проекта, поэтому здесь, в большей степени, предлагается механизм для внедрения собственных сериализаторов, а дефолтные просто реализуют наиболее общий подход.

### Итерация по реквизитам

Реквизиты в подклассах `GostBill` могут итерироваться в том порядке, котором они были декларированы. Так как они поддерживают вызовы `iter` и `next`, это, соответственно, позволяет использовать их и в цикле `for`.

При итерации будут возвращены объекты `FieldInstance`, а не прямые значения.

```python
for field in new_bill:
	print(field.model.short, field.value, sep=': ')
```

Кроме того, возможно обращение к полю по числовому индексу:

```python
new_bill[0]

>>> FieldInstance(name='amount', model=RequisiteModel(definition='Sum', short='Сумма (коп.)', long='Сумма платежа в копейках', required=False, validator=gostbill.validators.Sum), value='100')
```

### Под капотом

Технически, вы можете получить список названий ваших полей через приватный атрибут `_fieldnames`...

```python
new_bill._fieldnames

>>> ['amount', 'recipient']
```

...а к моделям реквизитов обратиться через приватный атрибут `_attrs`, который возвращает их в виде `types.SimpleNamespace`:

```python
new_bill._attrs.amount.long

>>> 'Сумма платежа в копейках'
```

Это внутренний API, который вряд ли пригодится кому-то в реальных проектах. Однако, в редких случаях он может быть полезен (наверное). Так же только для чтения.

## Счёт

Как уже говорилось в начале, для декларации класса шаблона нужно унаследоваться от класса `GostBill`.

### Параметры счёта

Помимо списка реквизитов, формат QR-кода включает служебную информацию. Как правило, установок по умолчанию достаточно, но могут быть ситуации, когда их надо изменить.

Для хранения установок определён тип `ServiceData`, который содержит параметры:

  - `encoding`: цифровой код кодировки текста (см. ниже)
  - `format_id`: формат данных
  - `format_version`: версия формата данных

Настройки хранятся в атрибуте шаблона `service_data`, и могут быть переопределены при декларации. Для всех параметров определены собственные `Enum`-классы:

  - `ServiceData.Charset`
  - `ServiceData.FormatID`
  - `ServiceData.FormatVersion`

Однако, в текущей версии ГОСТ разные варианты имеет только параметр `encoding`. Соответственно, это единственный параметр, который в настоящий момент может понадобиться переопределить.

```python
from gostbill import GostBill, ServiceData, fields


class Bill(GostBill):
	"""Description of bill"""

	# Переопределение дефолтной кодировки
	service_data = ServiceData(encoding=ServiceData.Charset.KOI8_R)

	amount = fields.Sum()
	recipient = fields.Name()
```

*ГОСТ прямо рекомендует использование 1-битных кодировок для большей ёмкости текста. Однако, на практике, российские банки, как правило, используют UTF-8. Поэтому, эта кодировка установлена по умолчанию.*

Сейчас ГОСТ допускает три кодировки, которым в `ServiceData.Charset` соответствуют одноимённые константы:

- `WIN1251`
- `UTF8`
- `KOI8_R`

В Python тип `str` использует UTF-8. Поэтому для работы с однобайтными кодировками нужно использовать не строковое, а байтовое представление экземпляра класса.

```python
new_bill = Bill()
new_bill.amount = 100
new_bill.recipient = 'Сидоров'

bytes(new_bill)
```

Результат KOI-8-R в Unicode-выводе:

```python
b'ST00013|Sum=100|Name=\xf3\xc9\xc4\xcf\xd2\xcf\xd7'
```

Помимо `service_data`, шаблон счёта использует параметр `delimiter`, всегда равный символу прямой черты: `|`. Это единственно допустимый по ГОСТ разделитель, и для формирования QR его не требуется переопределять. Но если назначить ему любое другое строковое значение, это будет работать:

```python
class Bill(GostBill):
	delimiter = ';'
	...

>>> 'ST00012;Sum=100;Name=Сидоров'
```

### Функция `len()`

При использовании `len(new_bill)` будет возвращено **количество полей в счёте** (в нашем примере `2`), а **не длина строки** для qr-кода (в нашем примере `28`). Для строки нужно вычислять непосредственно её длину: `len(str(new_bill))` или `len(bytes(new_bill))`.

### Сериализация счёта

Сериализация счёта устроена иначе, чем сериализация поля. Экземпляр подкласса `GostBill` содержит свойство `serializer`, возвращающий объект `BillSerializer` из модуля `serializers`. Он, в свою очередь, содержит метод `serialize()`, возвращающий словарь, и строковое представление, возвращающее json на основе этого словаря (см. пример в начале).

Так как поля счёта итерируются и могут принимать кастомный сериализатор, у вас развязаны руки:

```python
from gostbill import GostBill, FieldInstance


class HTMLSerializer:
    def __init__(self, field: FieldInstance):
        self.field = field

    def serialize(self) -> str:
        return f"""
        <h2>{self.field.name}</h2>
        <ul>
            <li>value: {self.field.value}</li>
            <li>description: {self.field.model.long}</li>
        </ul>
"""

	def __str__(self):
		return self.serialize()


def bill_html(bill: GostBill):
    fields_html = ''.join(field.serialize(HTMLSerializer) for field in bill)
    return f"""
<html>
    <body>
        <h1>{bill.__class__.__name__}</h1>
        <p>{bill.__doc__}</p>
        <code>{bill}</code>
        {fields_html}
    </body>
<html>
"""


print(bill_html(new_bill))
```

Результат:

```html
<html>
    <body>
        <h1>Bill</h1>
        <p>Description of bill</p>
        <code>ST00012|Sum=100|Name=Сидоров</code>

        <h2>amount</h2>
        <ul>
            <li>value: 100</li>
            <li>description: Сумма платежа в копейках</li>
        </ul>

        <h2>recipient</h2>
        <ul>
            <li>value: Сидоров</li>
            <li>description: Наименование получателя платежа</li>
        </ul>

    </body>
<html>
```

В целом, сериализация зависит от конкретного проекта, поэтому здесь, в большей степени, предлагается механизм для внедрения собственных сериализаторов, а не готовые решения. Кроме того, это не основной функционал.

## Типы исключений

При проверке корректности работы дескриптора реквизитов используется исключение `core.RequisiteError`. Оно будет вызвано, если пользовательские поля реквизитов определены неверно.

Более полезным является исключение `validators.RequisiteValidationError`, вызываемое при валидации присваиваемых значений. Оно возвращает подробную информацию об ошибке на русском языке со ссылкой на соответствующий параграф в ГОСТ.

Например, попытка неверно обозначить БИК:

```python
from gostbill import GostBill, fields


class Bill(GostBill):
    amount = fields.Sum()
    recipient = fields.Name()
    bic = fields.BIC()


new_bill = Bill()
new_bill.amount = 100
new_bill.bic = '0921247'
```

Вызовет исключение:

```python
RequisiteValidationError: "ГОСТ § 5.2.3, Таблица 2: БИК — Строка цифр строго 9 знаков. Вы передали BIC '0921247', знаков: 7"
```
## Стандартные формы счетов

Согласно ГОСТ, в кодируемой строке допустимы три блока реквизитов

Блок 1. Обязательные, определённые в блоке «Payee» УФЭБС:
- `Name`
- `PersonalAcc`
- `BankName`
- `BIC`
- `CorrespAcc`

Блок 2. Дополнительные, согласно Альбому УФЭБС:
  - `Sum`
  - `Puprose`
  - `PayeeINN`
  - `PayerINN`
  - `DrawerStatus`
  - `KPP`
  - `CBC`
  - `OKTMO`
  - `PaytReason`
  - `TaxPeriod`
  - `DocNo`
  - `DocDate`
  - `TaxPaytKind`

Блок 3. Прочие дополнительные реквизиты.

Может возникнуть необходимость проверки этих условий. Для этого определены три свойства экземпляра счёта:

  - `required_satisfied`:  вернёт`True`, если все обязательные реквизиты из п. 1 определены, иначе `False`
  - `additional_satisfied`: вернёт `True`, если все необязательные реквизиты из п. 2 определены, иначе `False`
  - `definitions_correct`: вернёт `True`, если все указанные реквизиты содержат корректные значения `model.definition` (иными словами, названия всех указанных реквизитов присутствуют в ГОСТ).

Таким образом, минимальная проверка счёта на то, что его шаблон соответствует требованиям ГОСТ, выглядит так:

```python
assert new_bill.required_satisfied and new_bill.definitions_correct

>>> False
```

В нашем рабочем примере все поля названы корректно, но не все обязательные поля указаны, поэтому вернётся `False`.

Важно знать, что не все банки требуют соблюдения этих требований при выставлении счёта, поэтому такая проверка нужна не всегда.

Если вам нужны специфичные проверки, используйте Enum-класс `BankingDetails` из модуля `core_models`. Он содержит константы `REQUIRED` (для блока 1), `ADDITIONAL` (для блока 2) и `OPTIONAL` (для блока 3). Их значениями являются множества (`set`) строковых наименований полей, входящих в каждый блок. Объединённое множество из всех трёх доступно в методе класса `full_set()`.

```python
from gostbill.core_models import BankingDetails


print(OurNameModel.definition in BankingDetails.full_set())
>>> True

print(OurNameModel.definition in BankingDetails.ADDITIONAL)
>>> False
```

## Счета с заранее заполненными реквизитами

Как правило, в жизни мы заполняем счета, на которых, как минимум, реквизиты получателя уже напечатаны. В проекте, например, это могут быть одни и те же шаблоны, выставляемые несколькими банками для разных плательщиков.

В этом случае, помимо определения пустого шаблона, возникает необходимость иметь его несколько частично заполненных вариантов. Это можно сделать при помощи класса-фабрики, в котором заранее задаются некоторые значения. Затем фабрика возвращает экземпляр счёта на основе переданного шаблона, в котором поля заполнены согласно образцу.

```python
from gostbill.factories import BillFactory


class HerculesFactory(BillFactory):
	recipient = 'Полыхаев'
	bic = '284016348'
	wrong = 'Такого поля в шаблоне нет'


another_bill = HerculesFactory.create_bill(Bill)
another_bill.amount = 1000
```

Поля, которые объявлены в фабрике, но отсутствуют в переданном классе, будут проигнорированы. Это позволяет гибко задавать наборы реквизитов, которые могут применяться к шаблонам с разным набором полей, и безболезненно передавать разные по структуре шаблоны в одну и ту же фабрику.

```python
>>> another_bill
>>> Bill(Sum=1000, Name=Полыхаев, BIC=284016348)

>>> str(another_bill)
>>> 'ST00012|Sum=1000|Name=Полыхаев|BIC=284016348'
```

  Возвращаемый экземпляр счёта ничем не отличается от заполненного "вручную", и автоматически заполненные фабрикой поля реквизитов впоследствии могут редактироваться без каких-то специальных ограничений.

## Поля реквизитов из модуля `fields`

| ГОСТ              | SHORT                              | LONG                                                              | REQUIRED | VALIDATOR                                 |
| ----------------- | ---------------------------------- | ----------------------------------------------------------------- | -------- | ----------------------------------------- |
| `Name`            | Получатель                         | Наименование получателя платежа                                   | `True`   | `Name(name) -> str`                       |
| `PersonalAcc`     | Расчётный счёт                     | Расчётный счёт получателя платежа                                 | `True`   | `PersonalAcc(personalacc) -> str`         |
| `BankName`        | Банк                               | Наименование банка получателя платежа                             | `True`   | `BankName(bankname) -> str`               |
| `BIC`             | БИК                                | Банковский идентификационный код РФ                               | `True`   | `BIC(bic) -> str`                         |
| `CorrespAcc`      | Коррсчёт                           | Корреспондентский счёт банка                                      | `True`   | `CorrespAcc(correspacc) -> str`           |
| `Sum`             | Сумма (коп.)                       | Сумма платежа в копейках                                          | `False`  | `Sum(sum_) -> str`                        |
| `Puprose`         | Назначение                         | Наименование платежа (назначение)                                 | `False`  | `Puprose(puprose) -> str`                 |
| `PayeeINN`        | ИНН получателя                     | Идентификационный номер налогоплательщика получателя платежа      | `False`  | `PayeeINN(payeeinn) -> str`               |
| `PayerINN`        | ИНН плательщика                    | Идентификационный номер налогоплательщика плательщика платежа     | `False`  | `PayerINN(payerinn) -> str`               |
| `DrawerStatus`    | Статус составителя                 | Статус составителя платёжного документа                           | `False`  | `DrawerStatus(drawerstatus) -> str`       |
| `KPP`             | КПП                                | Код причины постановки на учет                                    | `False`  | `KPP(kpp) -> str`                         |
| `CBC`             | КБК                                | Код бюджетной классификации                                       | `False`  | `CBC(cbc) -> str`                         |
| `OKTMO`           | ОКТМО                              | Общероссийский классификатор территорий муниципальных образований | `False`  | `OKTMO(oktmo) -> str`                     |
| `PaytReason`      | Основание налогового платежа       | Основание налогового платежа                                      | `False`  | `PaytReason(paytreason) -> str`           |
| `TaxPeriod`       | Налоговый период                   | Налоговый период                                                  | `False`  | `TaxPeriod(taxperiod) -> str`             |
| `DocNo`           | Номер документа                    | Номер документа                                                   | `False`  | `DocNo(docno) -> str`                     |
| `DocDate`         | Дата документа                     | Дата документа                                                    | `False`  | `DocDate(docdate) -> str`                 |
| `TaxPaytKind`     | Тип платежа                        | Тип платежа                                                       | `False`  | `TaxPaytKind(taxpaytkind) -> str`         |
| `LastName`        | Фамилия                            | Фамилия плательщика                                               | `False`  | `LastName(lastname) -> str`               |
| `FirstName`       | Имя                                | Имя плательщика                                                   | `False`  | `FirstName(firstname) -> str`             |
| `MiddleName`      | Отчество                           | Отчество плательщика                                              | `False`  | `MiddleName(middlename) -> str`           |
| `PayerAddress`    | Адрес плательщика                  | Адрес плательщика                                                 | `False`  | `PayerAddress(payeraddress) -> str`       |
| `PersonalAccount` | Лицевой счёт                       | Лицевой счёт бюджетного получателя                                | `False`  | `PersonalAccount(personalaccount) -> str` |
| `DocIdx`          | Индекс                             | Индекс платёжного документа                                       | `False`  | `DocIdx(docidx) -> str`                   |
| `PensAcc`         | СНИЛС                              | Страховой номер индивидуального лицевого счета                    | `False`  | `PensAcc(pensacc) -> str`                 |
| `Contract`        | Номер договора                     | Номер договора                                                    | `False`  | `Contract(contract) -> str`               |
| `PersAcc`         | Номер лицевого счёта               | Номер лицевого счета плательщика в организации                    | `False`  | `PersAcc(persacc) -> str`                 |
| `Flat`            | Квартира                           | Номер квартиры                                                    | `False`  | `Flat(flat) -> str`                       |
| `Phone`           | Телефон                            | Номер телефона                                                    | `False`  | `Phone(phone) -> str`                     |
| `PayerIdType`     | Документ                           | Вид документа, удостоверяющего личность плательщика               | `False`  | `PayerIdType(payeridtype) -> str`         |
| `PayerIdNum`      | Номер документа                    | Номер документа, удостоверяющего личность плательщика             | `False`  | `PayerIdNum(payeridnum) -> str`           |
| `ChildFio`        | ФИО ребёнка/учащегося              | ФИО ребёнка/учащегося                                             | `False`  | `ChildFio(childfio) -> str`               |
| `BirthDate`       | Дата рождения                      | Дата рождения                                                     | `False`  | `BirthDate(birthdate) -> str`             |
| `PaymTerm`        | Срок платежа/счёта                 | Срок платежа или выставления счёта                                | `False`  | `PaymTerm(paymterm) -> str`               |
| `PaymPeriod`      | Период оплаты                      | Период оплаты                                                     | `False`  | `PaymPeriod(paymperiod) -> str`           |
| `Category`        | Вид платежа                        | Вид платежа                                                       | `False`  | `Category(category) -> str`               |
| `ServiceName`     | Код услуги/прибор учёта            | Код услуги или название прибора учёта                             | `False`  | `ServiceName(servicename) -> str`         |
| `CounterId`       | Номер прибора                      | Номер прибора учёта                                               | `False`  | `CounterId(counterid) -> str`             |
| `CounterVal`      | Показания                          | Показание прибора учёта                                           | `False`  | `CounterVal(counterval) -> str`           |
| `QuittId`         | Номер документа об оплате          | Номер извещения, начисления, счёта или постановления (для ГИБДД)  | `False`  | `QuittId(quittid) -> str`                 |
| `QuittDate`       | Дата документа об оплате           | Дата извещения, начисления, счёта или постановления (для ГИБДД)   | `False`  | `QuittDate(quittdate) -> str`             |
| `InstNum`         | Номер учреждения                   | Номер учреждения (образовательного, медицинского)                 | `False`  | `InstNum(instnum) -> str`                 |
| `ClassNum`        | Номер группы/класса                | Номер группы детского сада или класса школы                       | `False`  | `ClassNum(classnum) -> str`               |
| `SpecFio`         | ФИО специалиста                    | ФИО преподавателя, специалиста, оказывающего услугу               | `False`  | `SpecFio(specfio) -> str`                 |
| `AddAmount`       | Сумма начисления                   | Сумма страховки, дополнительной услуги или пени                   | `False`  | `AddAmount(addamount) -> str`             |
| `RuleId`          | Номер постановления                | Номер постановления (для ГИБДД)                                   | `False`  | `RuleId(ruleid) -> str`                   |
| `ExecId`          | Номер исполнительного производства | Номер исполнительного производства                                | `False`  | `ExecId(execid) -> str`                   |
| `RegType`         | Код платежа                        | Код вида платежа                                                  | `False`  | `RegType(regtype) -> str`                 |
| `UIN`             | УИН                                | Уникальный идентификатор начисления                               | `False`  | `UIN(uin) -> str`                         |
| `TechCode`        | Технический код                    | Технический код, рекомендуемый для заполнения поставщиком услуг   | `False`  | `TechCode(techcode) -> str`               |
